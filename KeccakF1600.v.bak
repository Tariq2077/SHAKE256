`timescale 1ns / 1ps

module KeccakF1600  (
    input             clk,
    input             rst_n,
    input             start,
    output reg        done,
    output reg [1599:0] state_out
);

//------------------ FSM States ------------------
localparam FSM_IDLE  = 2'd0;
localparam FSM_ROUND = 2'd1;
localparam FSM_DONE  = 2'd2;

reg [1:0]  fsm;

localparam ROUND_COUNT = 24;
reg [4:0]  round_idx; 
wire       last_round = (round_idx == (ROUND_COUNT - 1));

//------------------ State: 25 lanes x 64 bits ----------------
reg [63:0] state_reg[0:24]; // the “current state”
reg [63:0] next_state[0:24]; // the “next state” for one round

//------------------ Round Constants RC[0..23] ----------------
wire [63:0] RC [0:23];
assign RC[ 0] = 64'h0000000000000001;
assign RC[ 1] = 64'h0000000000008082;
assign RC[ 2] = 64'h800000000000808A;
assign RC[ 3] = 64'h8000000080008000;
assign RC[ 4] = 64'h000000000000808B;
assign RC[ 5] = 64'h0000000080000001;
assign RC[ 6] = 64'h8000000080008081;
assign RC[ 7] = 64'h8000000000008009;
assign RC[ 8] = 64'h000000000000008A;
assign RC[ 9] = 64'h0000000000000088;
assign RC[10] = 64'h0000000080008009;
assign RC[11] = 64'h000000008000000A;
assign RC[12] = 64'h000000008000808B;
assign RC[13] = 64'h800000000000008B;
assign RC[14] = 64'h8000000000008089;
assign RC[15] = 64'h8000000000008003;
assign RC[16] = 64'h8000000000008002;
assign RC[17] = 64'h8000000000000080;
assign RC[18] = 64'h000000000000800A;
assign RC[19] = 64'h800000008000000A;
assign RC[20] = 64'h8000000080008081;
assign RC[21] = 64'h8000000000008080;
assign RC[22] = 64'h0000000080000001;
assign RC[23] = 64'h8000000080008008;

//------------------ Rho Offsets [0..24], each 6 bits -------------
wire [5:0] RHO_OFFSETS [0:24];
assign RHO_OFFSETS[ 0] = 6'd0;   assign RHO_OFFSETS[ 1] = 6'd1;
assign RHO_OFFSETS[ 2] = 6'd62;  assign RHO_OFFSETS[ 3] = 6'd28;
assign RHO_OFFSETS[ 4] = 6'd27;  assign RHO_OFFSETS[ 5] = 6'd36;
assign RHO_OFFSETS[ 6] = 6'd44;  assign RHO_OFFSETS[ 7] = 6'd6;
assign RHO_OFFSETS[ 8] = 6'd55;  assign RHO_OFFSETS[ 9] = 6'd20;
assign RHO_OFFSETS[10] = 6'd3;   assign RHO_OFFSETS[11] = 6'd10;
assign RHO_OFFSETS[12] = 6'd43;  assign RHO_OFFSETS[13] = 6'd25;
assign RHO_OFFSETS[14] = 6'd39;  assign RHO_OFFSETS[15] = 6'd41;
assign RHO_OFFSETS[16] = 6'd45;  assign RHO_OFFSETS[17] = 6'd15;
assign RHO_OFFSETS[18] = 6'd21;  assign RHO_OFFSETS[19] = 6'd8;
assign RHO_OFFSETS[20] = 6'd18;  assign RHO_OFFSETS[21] = 6'd2;
assign RHO_OFFSETS[22] = 6'd61;  assign RHO_OFFSETS[23] = 6'd56;
assign RHO_OFFSETS[24] = 6'd14;

//------------------ Helper function: rotate_left_64 ------------
function [63:0] rotate_left_64;
  input [63:0] val;
  input [5:0]  shift_amt;
begin
  rotate_left_64 = (val << shift_amt) | (val >> (64 - shift_amt));
end
endfunction

// Temporary arrays for the round logic in the FSM
// (We declare them as module-scope so we can do everything inline. 
//  That avoids tasks with local variables that older Verilog might reject.)
reg [63:0] C[0:4];
reg [63:0] D[0:4];
reg [63:0] B[0:24];
reg [63:0] T[0:24];

integer i, x, y;          // needed for for-loops
integer in_idx, out_idx;  // indexing

//------------------------------------------------------------
// The single always block that runs the FSM, 
// does the round computations inline (no tasks).
//------------------------------------------------------------
always @(posedge clk or negedge rst_n) begin
    if(!rst_n) begin
        // initialize state_reg to zero
        for(i=0; i<25; i=i+1) begin
            state_reg[i] <= 64'h0;
        end
        round_idx <= 0;
        done      <= 0;
        fsm       <= FSM_IDLE;
    end else begin

        case(fsm)
        FSM_IDLE: begin
            done <= 0;
            if(start) begin
                round_idx <= 0;
                fsm <= FSM_ROUND;
            end
        end

        FSM_ROUND: begin
            //-----------------------------------
            // 1) Next-state = state_reg initially
            for(i=0; i<25; i=i+1) begin
                next_state[i] = state_reg[i];
            end

            //--------------- Theta --------------
            // compute C[x]
            for(x=0; x<5; x=x+1) begin
                C[x] = next_state[x + 0] ^
                       next_state[x + 5] ^
                       next_state[x + 10] ^
                       next_state[x + 15] ^
                       next_state[x + 20];
            end
            // compute D[x]
            for(x=0; x<5; x=x+1) begin
                D[x] = C[(x+4)%5] ^ rotate_left_64(C[(x+1)%5], 6'd1);
            end
            // apply
            for(x=0; x<5; x=x+1) begin
                for(y=0; y<5; y=y+1) begin
                    next_state[x+5*y] = next_state[x+5*y] ^ D[x];
                end
            end

            //-------------- Rho + Pi -----------
            for(i=0; i<25; i=i+1) begin
                B[i] = 64'h0;
            end
            for(x=0; x<5; x=x+1) begin
                for(y=0; y<5; y=y+1) begin
                    in_idx  = x + 5*y;
                    B[ 5*((2*x + 3*y)%5) + y ] =
                        rotate_left_64(next_state[in_idx], RHO_OFFSETS[in_idx]);
                end
            end
            for(i=0; i<25; i=i+1) begin
                next_state[i] = B[i];
            end

            //---------------- Chi --------------
            for(i=0; i<25; i=i+1) begin
                T[i] = next_state[i];
            end
            for(y=0; y<5; y=y+1) begin
                for(x=0; x<5; x=x+1) begin
                    next_state[x+5*y] = T[x+5*y] ^
                        ((~T[((x+1)%5)+5*y]) & T[((x+2)%5)+5*y]);
                end
            end

            //---------------- Iota -------------
            next_state[0] = next_state[0] ^ RC[round_idx];

            // 2) Write next_state -> state_reg
            for(i=0; i<25; i=i+1) begin
                state_reg[i] <= next_state[i];
            end

            // 3) increment round
            if(last_round) begin
                fsm <= FSM_DONE;
            end
            round_idx <= round_idx + 1'b1;
        end

        FSM_DONE: begin
            done <= 1;
            fsm <= FSM_IDLE;
        end

        endcase
    end
end

//------------------------------------------------------------
// Flatten state_reg => state_out
//------------------------------------------------------------
always @* begin
    // ascending index i
    state_out = {
      state_reg[24], state_reg[23], state_reg[22], state_reg[21], state_reg[20],
      state_reg[19], state_reg[18], state_reg[17], state_reg[16], state_reg[15],
      state_reg[14], state_reg[13], state_reg[12], state_reg[11], state_reg[10],
      state_reg[9],  state_reg[8],  state_reg[7],  state_reg[6],  state_reg[5],
      state_reg[4],  state_reg[3],  state_reg[2],  state_reg[1],  state_reg[0]
    };
end

endmodule
