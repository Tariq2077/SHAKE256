`timescale 1ns/1ps
module DomainPad #(
    parameter range = 1088,
    // 0x1F = 5 bits = 11111 for SHAKE
    parameter [4:0] DOMAIN = 5'h1F
)(
    input  wire clk,
    input  wire reset,

    // user message (serial)
    input  wire enable,
    input  wire serial_in,
    input  wire serial_end_signal,

    input  wire block_consumed,

    output reg [range-1:0] message,
    output reg valid_output,
    output reg error_flag,
    output reg pad_done,

    // Debug
    output reg [2:0]  debug_pad_state,
    output reg [10:0] debug_pad_bitcount
);

    // We do states:
    // 0) INPUT – gather user bits
    // 1) DOMAIN – append the domain bits (4 or 5 bits)
    // 2) PAD ONE – append “1”
    // 3) PAD ZERO – fill with 0 until last bit
    // 4) DONE
    // 5) CONSUMED

    localparam [2:0]
        STATE_INPUT  = 3'd0,
        STATE_DOMAIN = 3'd1,
        STATE_PADONE = 3'd2,
        STATE_PADZRO = 3'd3,
        STATE_DONE   = 3'd4,
        STATE_CONS   = 3'd5;

    reg [2:0] state;

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            message          <= {range{1'b0}};
            valid_output     <= 1'b0;
            error_flag       <= 1'b0;
            pad_done         <= 1'b0;
            debug_pad_bitcount <= 0;
            state            <= STATE_INPUT;
        end
        else begin
            case(state)
                STATE_INPUT: begin
                    if (serial_end_signal) begin
                        // Move to domain insertion
                        state <= STATE_DOMAIN;
                    end
                    else if (enable) begin
                        if (debug_pad_bitcount < range) begin
                            message[debug_pad_bitcount] <= serial_in;
                            debug_pad_bitcount <= debug_pad_bitcount + 1;
                        end else begin
                            error_flag <= 1'b1;
                            state <= STATE_DONE;
                        end
                    end
                end

                STATE_DOMAIN: begin
                    // Insert 5 bits from DOMAIN at the next 5 positions
                    // e.g. if bitcount=10, we do:
                    //   message[10] <= DOMAIN[0]
                    //   message[11] <= DOMAIN[1]
                    // ...
                    integer k;
                    for (k = 0; k < 5; k = k + 1) begin
                        if (debug_pad_bitcount < range) begin
                            message[debug_pad_bitcount + k] <= DOMAIN[k];
                        end else begin
                            error_flag <= 1'b1;
                            state <= STATE_DONE;
                        end
                    end
                    debug_pad_bitcount <= debug_pad_bitcount + 5;
                    // Then pad with “1” => next state
                    state <= STATE_PADONE;
                end

                STATE_PADONE: begin
                    if (debug_pad_bitcount < range) begin
                        // single “1” bit
                        message[debug_pad_bitcount] <= 1'b1;
                        debug_pad_bitcount <= debug_pad_bitcount + 1;
                    end else begin
                        error_flag <= 1'b1;
                    end
                    state <= STATE_PADZRO;
                end

                STATE_PADZRO: begin
                    // Fill with 0 until the last bit
                    if (debug_pad_bitcount < (range-1)) begin
                        message[debug_pad_bitcount] <= 1'b0;
                        debug_pad_bitcount <= debug_pad_bitcount + 1;
                    end else begin
                        // done
                        state <= STATE_DONE;
                    end
                end

                STATE_DONE: begin
                    valid_output <= 1'b1;
                    pad_done     <= 1'b1;
                    if (block_consumed) begin
                        valid_output <= 1'b0;
                        state <= STATE_CONS;
                    end
                end

                STATE_CONS: begin
                    // remain
                end

                default: state <= STATE_DONE;
            endcase
        end
    end

    always @(*) begin
        debug_pad_state = state;
    end

endmodule
