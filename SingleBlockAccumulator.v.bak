`timescale 1ns/1ps
module SingleBlockAccumulator #(
    parameter RATE_BITS = 1088
)(
    input  wire             clk,
    input  wire             reset,
    
    // Control from the Control_Unit:
    input  wire             accum_start,     // one-cycle pulse to begin collecting
    input  wire             enable_2bit,     // each clock, if =1, read 2 bits from serial_in
    input  wire [1:0]       serial_in,       
    input  wire             serial_end_signal, // user says no more data
    output reg              accum_done,      // 1 when block is fully ready
    output reg [RATE_BITS-1:0] block_out     // the final 1088-bit block

    // You could add a 'block_full' or 'ignored_data' signal if you want to track overflows
);

  // 1088 bits => 136 bytes
  localparam BYTES_PER_BLOCK = RATE_BITS / 8; // = 136

  // We'll store each byte in a small array
  reg [7:0] buffer_mem [0:BYTES_PER_BLOCK-1];

  // Indices/counters
  reg [10:0] byte_index;  // which byte 0..135
  reg [1:0]  chunk_count; // how many 2-bit lumps in temp_byte
  reg [7:0]  temp_byte;

  // Because older Verilog doesn't allow inline integer, declare them here:
  integer i, j;

  // FSM states
  localparam [2:0]
    ST_IDLE   = 3'd0,
    ST_COLLECT= 3'd1,
    ST_PAD    = 3'd2,
    ST_DONE   = 3'd3;

  reg [2:0] state, next_state;

  // Synchronous
  always @(posedge clk or posedge reset) begin
    if (reset) begin
      state       <= ST_IDLE;
      accum_done  <= 1'b0;
      block_out   <= {RATE_BITS{1'b0}};
      // clear memory
      for(i=0; i<BYTES_PER_BLOCK; i=i+1)
        buffer_mem[i] <= 8'h00;

      byte_index  <= 0;
      chunk_count <= 0;
      temp_byte   <= 8'h00;
    end else begin
      state <= next_state;

      case (state)
        ST_IDLE: begin
          accum_done <= 1'b0;
          // On accum_start, we clear the buffer
          if (accum_start) begin
            for(i=0; i<BYTES_PER_BLOCK; i=i+1)
              buffer_mem[i] <= 8'h00;
            byte_index  <= 0;
            chunk_count <= 0;
            temp_byte   <= 8'h00;
          end
        end

        ST_COLLECT: begin
          // If enable_2bit=1, read 2 bits:
          if (enable_2bit) begin
            // Place them LSB-first:
            temp_byte[2*chunk_count +: 2] <= serial_in;
            chunk_count <= chunk_count + 1'b1;

            // If we've got 4 chunks => 8 bits => store in buffer
            if (chunk_count == 2'd3) begin
              // If we haven't filled up
              if (byte_index < BYTES_PER_BLOCK) begin
                buffer_mem[byte_index] <= temp_byte;
                byte_index  <= byte_index + 1'b1;
              end
              // If byte_index >= BYTES_PER_BLOCK, we're ignoring further data
              // (We could set a 'block_full' flag here if you want)
              temp_byte   <= 8'h00;
              chunk_count <= 2'd0;
            end
          end

          // If we filled the entire 136 bytes => go to pad
          if (byte_index == BYTES_PER_BLOCK) begin
            next_state <= ST_PAD; // Or do ST_DONE if you want to skip domain separation
          end

          // If user ended => pad
          if (serial_end_signal) begin
            next_state <= ST_PAD;
          end
        end

        ST_PAD: begin
          // We store partial leftover if chunk_count != 0
          if (chunk_count != 0 && byte_index < BYTES_PER_BLOCK) begin
            buffer_mem[byte_index] <= temp_byte;
            byte_index <= byte_index + 1'b1;
          end

          // Domain separation nibble => 0x1F (for SHAKE) if you want.
          // Then fill zeros, last byte => 0x80
          // Only do this once if we haven't already filled block.

          if (byte_index < BYTES_PER_BLOCK) begin
            buffer_mem[byte_index] <= 8'h1F;
            byte_index = byte_index + 1;
          end

          // fill up to last byte - 1 with 0
          for(j=byte_index; j<(BYTES_PER_BLOCK-1); j=j+1) begin
            buffer_mem[j] <= 8'h00;
          end

          // last byte => 0x80
          buffer_mem[BYTES_PER_BLOCK-1] <= 8'h80;

          // Next state => ST_DONE
        end

        ST_DONE: begin
          // We'll build block_out from buffer_mem
          // to avoid a big for-loop each clock, do it here once
          for(j=0; j<BYTES_PER_BLOCK; j=j+1) begin
            block_out[8*j +: 8] <= buffer_mem[j];
          end
          accum_done <= 1'b1;
        end

      endcase
    end
  end

  // Next-state logic
  always @* begin
    next_state = state;
    case (state)
      ST_IDLE: begin
        if (accum_start) 
          next_state = ST_COLLECT;
      end
      ST_COLLECT: begin
        if (byte_index == BYTES_PER_BLOCK) 
          next_state = ST_PAD;
        else if (serial_end_signal)
          next_state = ST_PAD;
      end
      ST_PAD: begin
        next_state = ST_DONE;
      end
      ST_DONE: begin
        // Remain done until next run (accum_start again).
      end
      default: next_state = ST_IDLE;
    endcase
  end

endmodule
