`timescale 1ns/1ps
module SHAKE256 #(
    parameter MESSAGE_MAX_BITS = 8192, // Not used in one–block version.
    parameter STATE_WIDTH      = 1600,
    parameter RATE_WIDTH       = 1088,
    parameter CAPACITY_WIDTH   = 512,
    parameter OUT_BITS         = 256
)(
    input  wire clk,
    input  wire reset,
    // Serial input interface.
    input  wire enable,
    input  wire serial_in,
    input  wire serial_end_signal,
    // Start signal for cSHAKE256.
    input  wire start,
    output reg  done,
    output reg  [OUT_BITS-1:0] digest,
    // Debug output for the FSM state.
    output [3:0]  debug_cshake_fsm
);

    //--------------------------------------------------------------------------
    // FSM States (one–block operation)
    //--------------------------------------------------------------------------
    localparam [3:0]
        IDLE     = 4'd0,
        WAIT_PAD = 4'd1,
        ABSORB   = 4'd2,
        WAIT_ABS = 4'd3,
        PERMUTE  = 4'd4,
        WAIT_K   = 4'd5,
        SQUEEZE  = 4'd6,
        WAIT_SQ  = 4'd7,
        TRUNC    = 4'd8,
        DONE_S   = 4'd9;

    // FSM state registers.
    reg [3:0] cshake_fsm, cshake_fsm_next;

    // We'll hold our internal 1600‐bit state in registers.
    reg [STATE_WIDTH-1:0] absorb_state_reg, keccak_state_reg;
    reg [STATE_WIDTH-1:0] absorb_state_next, keccak_state_next;

    // Control signals for the sub–modules.
    reg absorb_start;
    reg keccak_start;
    reg squeeze_opcode;

    //--------------------------------------------------------------------------
    // Instantiate the pad module.
    //--------------------------------------------------------------------------
    wire [RATE_WIDTH-1:0] pad_block;
    wire pad_valid, pad_error, pad_done;
    // For one–block operation, we tie block_consumed to 0.
    wire block_consumed = 1'b0;

    pad #(.range(RATE_WIDTH)) pad_inst (
        .clk(clk),
        .reset(reset),
        .enable(enable),
        .serial_in(serial_in),
        .serial_end_signal(serial_end_signal),
        .block_consumed(block_consumed),
        .message(pad_block),
        .valid_output(pad_valid),
        .error_flag(pad_error),
        .pad_done(pad_done),
        .debug_pad_state(),        // Unconnected in this version.
        .debug_pad_bitcount()
    );

    //--------------------------------------------------------------------------
    // Instantiate the Absorb module.
    //--------------------------------------------------------------------------
    wire [STATE_WIDTH-1:0] absorb_out;
    wire absorb_done;
    // Form a 1600–bit block by placing the pad block into the rate portion.
    wire [STATE_WIDTH-1:0] absorb_block = { {(STATE_WIDTH-RATE_WIDTH){1'b0}}, pad_block };

    Absorb absorb_inst (
        .clk(clk),
        .start(absorb_start),
        .state_in(absorb_state_reg),
        .Block(absorb_block),
        .absorb_state_out(absorb_out),
        .done_absorb(absorb_done),
        .debug_absorb_i()         // Optional debug port.
    );

    //--------------------------------------------------------------------------
    // Instantiate the KeccakF1600 module.
    //--------------------------------------------------------------------------
    wire [STATE_WIDTH-1:0] keccak_out;
    wire keccak_done;
    KeccakF1600 keccak_inst (
        .clk(clk),
        .rst_n(~reset),
        .start(keccak_start),
        .state_in(keccak_state_reg),
        .state_out(keccak_out),
        .done(keccak_done),
        .debug_kf_fsm(),           // Optional debug ports.
        .debug_kf_round()
    );

    //--------------------------------------------------------------------------
    // Instantiate the Squeeze module.
    //--------------------------------------------------------------------------
    wire [RATE_WIDTH-1:0] squeeze_data;
    wire squeeze_done;
    squeeze squeeze_inst (
        .clk(clk),
        .opcode(squeeze_opcode),
        .Unsqueezed_data(keccak_out),
        .Squeezed_data(squeeze_data),
        .squeeze_done(squeeze_done),
        .debug_squeeze_start()     // Optional debug port.
    );

    //--------------------------------------------------------------------------
    // Instantiate the Truncate module.
    //--------------------------------------------------------------------------
    wire [OUT_BITS-1:0] truncated_data;
    // Set L_sel to OUT_BITS (i.e. take the top 256 bits).
    Truncate #(.WIDTH_IN(RATE_WIDTH), .MAX_L(OUT_BITS))
        truncate_inst (
            .Z(squeeze_data),
            .L_sel(OUT_BITS),
            .Y(truncated_data)
    );

    //--------------------------------------------------------------------------
    // FSM Combinational Logic:
    // Compute the next state of the FSM and next values for our internal state registers.
    // This single combinational block drives all next–value signals to avoid multiple drivers.
    //--------------------------------------------------------------------------
    always @(*) begin
        // Default: hold current state.
        cshake_fsm_next = cshake_fsm;
        absorb_state_next = absorb_state_reg;
        keccak_state_next = keccak_state_reg;
        absorb_start = 1'b0;
        keccak_start = 1'b0;
        squeeze_opcode = 1'b0;

        case (cshake_fsm)
            IDLE: begin
                if (start) begin
                    // Clear the state.
                    absorb_state_next = {STATE_WIDTH{1'b0}};
                    cshake_fsm_next = WAIT_PAD;
                end
            end
            WAIT_PAD: begin
                if (pad_valid)
                    cshake_fsm_next = ABSORB;
                else if (pad_error)
                    cshake_fsm_next = DONE_S;
            end
            ABSORB: begin
                absorb_start = 1'b1;
                cshake_fsm_next = WAIT_ABS;
            end
            WAIT_ABS: begin
                if (absorb_done) begin
                    keccak_state_next = absorb_out;
                    cshake_fsm_next = PERMUTE;
                end
            end
            PERMUTE: begin
                keccak_start = 1'b1;
                cshake_fsm_next = WAIT_K;
            end
            WAIT_K: begin
                if (keccak_done)
                    cshake_fsm_next = SQUEEZE;
            end
            SQUEEZE: begin
                squeeze_opcode = 1'b1;
                cshake_fsm_next = WAIT_SQ;
            end
            WAIT_SQ: begin
                if (squeeze_done)
                    cshake_fsm_next = TRUNC;
            end
            TRUNC: begin
                cshake_fsm_next = DONE_S;
            end
            DONE_S: begin
                cshake_fsm_next = DONE_S;  // Remain in DONE state.
            end
            default: cshake_fsm_next = DONE_S;
        endcase
    end

    //--------------------------------------------------------------------------
    // FSM Sequential Logic:
    // Update the FSM state and internal registers on the rising edge of clk.
    //--------------------------------------------------------------------------
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            cshake_fsm <= IDLE;
            absorb_state_reg <= {STATE_WIDTH{1'b0}};
            keccak_state_reg <= {STATE_WIDTH{1'b0}};
            done <= 1'b0;
            digest <= {OUT_BITS{1'b0}};
        end else begin
            cshake_fsm <= cshake_fsm_next;
            absorb_state_reg <= absorb_state_next;
            keccak_state_reg <= keccak_state_next;
            if (cshake_fsm_next == DONE_S)
                done <= 1'b1;
            else
                done <= 1'b0;
            if (cshake_fsm_next == TRUNC)
                digest <= truncated_data;
        end
    end

    assign debug_cshake_fsm = cshake_fsm;

endmodule
