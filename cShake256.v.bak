`timescale 1ns/1ps

module cShake256 #(
    parameter MESSAGE_MAX_BITS = 8192,  // a limit for your input msg
    parameter STATE_WIDTH      = 1600,  // Keccak-f state size
    parameter RATE_WIDTH       = 1088,  // rate for SHAKE256
    parameter CAPACITY_WIDTH   = 512,   // capacity = 512
    parameter OUT_BITS         = 256    // we want 256-bit output
)(
    input  wire                 clk,
    input  wire                 reset,
    //-------------------------------------------
    // Message input signals:
    input  wire                 enable,  // enable capturing serial bits
    input  wire                 serial_in,
    input  wire                 serial_end_signal, // message ended
    //-------------------------------------------
    // Start & done for the entire cShake256 operation
    input  wire                 start,
    output reg                  done,
    //-------------------------------------------
    // The final 256-bit digest
    output reg [OUT_BITS-1:0]   digest
);

    //=================================================
    // Submodules
    //=================================================

    // 1) pad
    // Produces a padded block (1088 bits) from the serial input
    // You described "pad" with parameter "range" = 16, but let's assume we adapt
    // it to produce 1088 bits. We'll keep your interface naming style:

    wire [RATE_WIDTH-1:0] pad_block;
    wire                   pad_valid_output;
    wire                   pad_error_flag;

    pad #(
        .range(RATE_WIDTH)
    ) pad_inst (
        .clk             (clk),
        .reset           (reset),
        .enable          (enable),
        .serial_in       (serial_in),
        .serial_end_signal(serial_end_signal),
        .message         (pad_block),
        .valid_output    (pad_valid_output),
        .error_flag      (pad_error_flag)
    );

    // 2) Absorb
    // We will pass a 1600-bit state + 1600-bit "Block" (though we only XOR the first 1088 bits).
    // We'll do it multi-cycle or single-cycle? The user provided "Absorb" which increments i 
    // up to 1600. We'll assume we use it as is:

    wire [1599:0] absorb_out;
    wire          absorb_done;
    reg           absorb_start;

    Absorb absorb_inst(
        .clk             (clk),
        .start           (absorb_start),
        .state_in        (/* we connect below in FSM */),
        .Block           (/* we connect below in FSM */),
        .absorb_state_out(absorb_out),
        .done_absorb     (absorb_done)
    );

    // 3) KeccakF1600
    // We have a 1600-bit state in, 1600-bit state out, done when 24 rounds finish:
    wire [1599:0] f1600_state_out;
    reg  [1599:0] f1600_state_in;
    reg           f1600_start;
    wire          f1600_done;

    KeccakF1600 keccakf1600_inst(
        .clk      (clk),
        .rst_n    (!reset),
        .start    (f1600_start),
        .state_in (f1600_state_in),
        .state_out(f1600_state_out),
        .done     (f1600_done)
    );

    // 4) Squeeze
    // Takes a 1600-bit input, outputs 1088 bits, sets squeeze_done
    wire [1087:0] squeeze_data;
    wire          squeeze_done;
    reg           squeeze_opcode; // 1 => start, 0 => stop

    squeeze squeeze_inst (
        .clk            (clk),
        .opcode         (squeeze_opcode),
        .Unsqueezed_data(/* connect from keccak_state in FSM */),
        .Squeezed_data  (squeeze_data),
        .squeeze_done   (squeeze_done)
    );

    // 5) Truncate
    // From your code: parameter WIDTH_IN=1088, we want up to 256 bits out 
    wire [OUT_BITS-1:0] truncated_data;
    reg  [$clog2(OUT_BITS)-1:0] L_sel; // We'll set this to 256
    Truncate #(
        .WIDTH_IN(1088),
        .MAX_L  (OUT_BITS)
    ) truncate_inst (
        .Z     (squeeze_data),
        .L_sel (L_sel),
        .Y     (truncated_data)
    );

    //=================================================
    // Internal 1600-bit state
    //=================================================
    reg [1599:0] keccak_state;
    reg [1599:0] next_keccak_state;

    //=================================================
    // FSM for cShake256
    //=================================================
    localparam [3:0] IDLE      = 4'd0,
                     WAIT_PAD  = 4'd1,
                     ABSORB    = 4'd2,
                     PERMUTE   = 4'd3,
                     CHECK_PAD = 4'd4,
                     SQUEEZE   = 4'd5,
                     TRUNC     = 4'd6,
                     DONE      = 4'd7;

    reg [3:0] cshake_fsm, cshake_fsm_next;

    // We'll do a simplified approach: first absorb all blocks from pad, then do a single squeeze to get 1088 bits, then truncate to 256. If you want repeated squeeze for L>1088, you'd loop.

    // FSM register
    always @(posedge clk or posedge reset) begin
        if(reset) begin
            cshake_fsm      <= IDLE;
            keccak_state    <= 1600'd0; // zero
            done            <= 1'b0;
            digest          <= {OUT_BITS{1'b0}};
        end else begin
            cshake_fsm      <= cshake_fsm_next;
            keccak_state    <= next_keccak_state;
        end
    end

    // Combinational next-state logic
    always @(*) begin
        // defaults
        cshake_fsm_next   = cshake_fsm;
        next_keccak_state = keccak_state;
        done              = 1'b0;

        absorb_start     = 1'b0;
        f1600_start      = 1'b0;
        squeeze_opcode   = 1'b0;
        L_sel            = OUT_BITS[$clog2(OUT_BITS)-1:0]; // = 256 if we want exactly 256 bits.

        case(cshake_fsm)
        IDLE: begin
            // Wait for start
            if(start) begin
                // Zero keccak_state
                next_keccak_state = 1600'd0;
                cshake_fsm_next = WAIT_PAD;
            end
        end

        WAIT_PAD: begin
            // Wait for pad to produce a valid 1088-bit block or finish
            if(pad_valid_output) begin
                cshake_fsm_next = ABSORB;
            end else if (pad_error_flag) begin
                // optional: handle error
                cshake_fsm_next = DONE;
            end
        end

        ABSORB: begin
            // Absorb => state_in=keccak_state, Block=some 1600bit?
            // Actually your pad only produces 1088 bits, but your Absorb module has 1600 bits for Block. 
            // We'll replicate those 1088 bits into the first 1088, zeros in the rest:
            absorb_start   = 1'b1;
        end

        PERMUTE: begin
            // Start keccakf1600 => 
            f1600_start    = 1'b1;
        end

        CHECK_PAD: begin
            // If pad is done => next step = SQUEEZE 
            // else => WAIT_PAD to get next block
        end

        SQUEEZE: begin
            // Squeeze => produce 1088 bits => store in squeeze_data
            // then TRUNC 
            squeeze_opcode = 1'b1;
        end

        TRUNC: begin
            // Now we have 1088 bits in squeeze_data, 
            // we pass L_sel=256 => truncated_data
            // assign final digest = truncated_data
        end

        DONE: begin
            done = 1'b1;
        end

        endcase
    end

    // Additional always blocks or tasks to handle the actual states 
    // assigning keccak_state from absorb_out or f1600_out, 
    // or repeating SQUEEZE if we wanted multiple 1088-bit chunks.

endmodule
