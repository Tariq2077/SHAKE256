`timescale 1ns/1ps

module absorb_tb;

  // Parameters for the Absorb module.
  localparam STATE_WIDTH = 1600;
  localparam RATE_WIDTH  = 1088;

  // Testbench signals.
  reg clk;
  reg reset;
  reg absorb_start;
  reg [STATE_WIDTH-1:0] state_in;
  reg [STATE_WIDTH-1:0] Block;
  wire [STATE_WIDTH-1:0] absorb_state_out;
  wire absorb_done;
  wire debug_absorb_state;
  wire [10:0] debug_absorb_i;

  // Instantiate the Absorb module.
  Absorb dut (
    .clk(clk),
    .reset(reset),
    .absorb_start(absorb_start),
    .state_in(state_in),
    .Block(Block),
    .absorb_state_out(absorb_state_out),
    .absorb_done(absorb_done),
    .debug_absorb_state(debug_absorb_state),
    .debug_absorb_i(debug_absorb_i)
  );

  // Clock generation: 10 ns period.
  initial clk = 0;
  always #5 clk = ~clk;

  // Test sequence.
  initial begin
    // Initialize signals.
    reset = 1;
    absorb_start = 0;
    state_in = {STATE_WIDTH{1'b0}};  // initial state is all zeros.
    Block = {STATE_WIDTH{1'b0}};
    
    // Wait a few cycles and deassert reset.
    #20;
    reset = 0;

    // Set Block:
    // We want to test that the first RATE_WIDTH bits are XORed.
    // Here we set the lower 1088 bits to all ones and upper 512 bits remain 0.
    Block = { {(STATE_WIDTH-RATE_WIDTH){1'b0}}, {RATE_WIDTH{1'b1}} };
    
    // Give a pulse to start the absorption.
    #10;
    absorb_start = 1;
    #10;
    absorb_start = 0;

    // Wait until the absorb module asserts absorb_done.
    wait (absorb_done == 1);
    
    // Display the resulting state (only show the first RATE_WIDTH bits for clarity).
    $display("Absorb test done. Lower %0d bits of absorb_state_out = %h", RATE_WIDTH, absorb_state_out[RATE_WIDTH-1:0]);
    // Expected result: Since state_in was 0 and Block was all 1's (in the lower RATE_WIDTH bits),
    // the lower 1088 bits should be all ones.

    $finish;
  end

endmodule
